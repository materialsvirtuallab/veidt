import itertools as it
import numpy as np
from veidt.mcts.operator import get_operators


def get_nsf(features, fnames, singular_op):
    "features generated by singular operators"
    nsf = []
    nsf_names = []
    num_features = features.shape[1]
    for ind in range(num_features):
        for op in singular_op:
            new_feature_array = np.expand_dims(op(features[:, ind]), axis=0)
            name = '(%s)' % (' '.join([op.__str__(), fnames[ind]]))
            if name in fnames:
                continue
            nsf.extend(new_feature_array)
            nsf_names.append(name)
    nsf = np.array(nsf)
    return nsf.T, nsf_names


def get_nbf(features, fnames, binary_op):
    "features generated by binary operators"
    num_feautres = features.shape[1]
    nbf = []
    nbf_names = []
    for a, b in it.combinations(range(num_feautres), 2):
        for op in binary_op:
            if op.__str__() == '/' and any(features[:, b] == 0):
                continue
            new_feature_array = np.expand_dims(op((features[:, a], features[:, b])), axis=0)
            name = '(%s)' % (' '.join([fnames[a], op.__str__(), fnames[b]]))
            if name in fnames:
                continue
            nbf.extend(new_feature_array)
            nbf_names.append(name)
            if op.order:
                if op.__str__() == '/' and any(features[:, a] == 0):
                    continue
                new_feature_array = np.expand_dims(op((features[:, b], features[:, a])), axis=0)
                name = '(%s)' % (' '.join([fnames[b], op.__str__(), fnames[a]]))
                if name in fnames:
                    continue
                nbf.extend(new_feature_array)
                nbf_names.append(name)
    nbf = np.array(nbf)
    return nbf.T, nbf_names


def generate_features(data=None, data_path=None, iteration=2, **kwargs):
    """

    Args:
        data: np.df , has the columns ['materials', 'properties', feature1, feature2, ....]
        iteration: number of iteration to generate features, default 2

    Returns:
        features, feature names

    """
    # if not data:
    #     data = pd.read_csv(data_path, sep=' ')
    features = data.values[:, 2:]
    fnames = list(data.columns[2:])
    singular_op, binary_op = get_operators(**kwargs)

    for it in range(iteration):
        nbf, nbf_names = get_nbf(features, fnames, binary_op)
        nsf, nsf_names = get_nsf(features, fnames, singular_op)
        features = np.append(features, nbf, axis=1)
        fnames.extend(nbf_names)
        features = np.append(features, nsf, axis=1)
        fnames.extend(nsf_names)
    # discard columns with invalid values
    valid_columns = ~np.isnan(features.astype('float64')).any(axis=0)
    fnames = [i for v, i in zip(valid_columns, fnames) if v]
    return features[:, valid_columns], fnames
